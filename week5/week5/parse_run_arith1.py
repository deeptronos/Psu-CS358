# Problem 2: Adding Exponentiation to Arithmetic Expressions

# This file is an almost unchanged copy of the parse_run_arith.py
# file discussed in class.  It relies on the grammar file expr1.lark
# and the interpreter interp_arith1.py.  This file and the grammar
# have been extended to include support for subtraction, division,
# and unary negation as shown at the end of class on 3Feb. 

# Your task is to make a further extend this set of files to 
# support exponentiation (written '^') in the language.
# This involves these steps:
#
# - Make new copies of these files called 
#   interp_arith2.py, expr2.lark, and parse_run_arith2.py.
# - In interp-arith2.py: Add a new class Exp to the AST to describe
#   the exponentiation operator, and implement this operator in the
#   interpreter. 
# - In expr2.lark: Extend the grammar to include the '^' operator.
# - In parse_run_arith2.py: Extend the ToExpr class to include exp operations,
#   (and adjust things to use interp_arity2.py and expr2.lark).
#

#
# Exponentiation should have higher precedence than any other
# operator, including unary negation, and it should be right associative.
# That is, an expression like -2^3^4 should parse to the same AST
# as -(2^(3^4))  --- and NOT the same thing as ((-2)^3)^4.
# These rules are typical (although not universal) for exponentiation.

from interp_arith1 import Add, Sub, Mul, Div, Neg, Let, Name, Lit, Expr, run

from lark import Lark, Token, ParseTree, Transformer
from lark.exceptions import VisitError
from pathlib import Path

parser = Lark(Path('expr1.lark').read_text(),start='expr',ambiguity='explicit')

class ParseError(Exception):
    pass

def parse(s:str) -> ParseTree:
    try:
        return parser.parse(s)
    except Exception as e:
        raise ParseError(e)

class AmbiguousParse(Exception):
    pass

class ToExpr(Transformer[Token,Expr]):
    '''Defines a transformation from a parse tree into an AST'''
    # This is structured as a "fold" over the parse tree.
    # There is a method for each named ("aliased") rule in the grammar,
    # invoked on nodes generated by that rule. 
    # The args are the _result_ of recursively 
    # applying the transformer to the children of the node
    # (we do not have to write the recursive calls explicitly).
    # For leaf nodes, the argument is a Token; the string that
    # actually makes up the token is in the .value field.
    # (We cheat by declaring the args as tuples rather than lists, since
    # this let's us be more precise about the types of the elements.)
    # Fail if tree contains ambiguity markers
    def plus(self, args:tuple[Expr,Expr]) -> Expr:
        return Add(args[0],args[1])
    def minus(self, args:tuple[Expr,Expr]) -> Expr:
        return Sub(args[0],args[1])
    def times(self, args:tuple[Expr,Expr]) -> Expr:
        return Mul(args[0],args[1])
    def divide(self, args:tuple[Expr,Expr]) -> Expr:
        return Div(args[0],args[1])
    def neg(self, args:tuple[Expr]) -> Expr:
        return Neg(args[0])            
    def let(self, args:tuple[Token,Expr,Expr]) -> Expr:
        return Let(args[0].value,args[1],args[2]) 
    def id(self, args:tuple[Token]) -> Expr:
        return Name(args[0].value)
    def int(self,args:tuple[Token]) -> Expr:
        return Lit(int(args[0].value))
    def _ambig(self,_) -> Expr:    # ambiguity marker
        raise AmbiguousParse()


def genAST(t:ParseTree) -> Expr:
    '''Applies the transformer to convert a parse tree into an AST'''
    # boilerplate to catch potential ambiguity error raised by transformer
    try:
        return ToExpr().transform(t)               
    except VisitError as e:
        if isinstance(e.orig_exc,AmbiguousParse):
            raise AmbiguousParse()
        else:
            raise e

def driver():
    while True:
        try:
            s = input('expr: ')
            t = parse(s)
            print("raw:", t)    
            print("pretty:")
            print(t.pretty())
            ast = genAST(t)
            print("raw AST:", repr(ast))  # use repr() to avoid str() pretty-printing
            run(ast)                      # pretty-prints and executes the AST
        except AmbiguousParse:
            print("ambiguous parse")                
        except ParseError as e:
            print("parse error:")
            print(e)
        except EOFError:
            break

driver()

